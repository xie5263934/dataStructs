package com.test.stringmatch;

import java.util.Arrays;

/**
 * BM字符串查的核心思想，首先我们认为模式串在主串上匹配的时候，相当于从主串的开始位置进行匹配，如果不匹配就把模式串在主串上往后滑动，
 * 普通的暴力算法就是一步一步的滑动，然后从左到右开始匹配，这样效率比较低，我们可以换一种思路，在匹配的时候从模式串的最后一个字符开始
 * 从后往前匹配，并且在从后往前匹配的过程中在主串中遇到的第一个不匹配的字符我们称为坏字符，而对于坏字符之后已经匹配成功的那个子串我们称为好后缀
 * 对于坏字符的处理，我们去模式串中查找这个坏字符在模式串中是否存在，并且找到它出现的最后一个位置。我们记在匹配的过程中主串中坏字符出现时模式串那个匹配
 * 不上的字符的位置为si，我们认为坏字符在模式串中最后一个出现的位置为xi，如果坏字符在模式串中没有出现，那么xi记为-1，如果出现了，那么取最后一次出现的
 * 位置，那么模式串在主串上往后滑动的距离就是si-xi，但是每次出现了坏字符的时候，如果我们都去模式串中查找一次这个坏字符出现的最后一个位置，效率太低，
 * 我们可以提前预处理，将模式串中每个字符出现的最后一个位置记录下来，这样坏字符可以直接查表来查找对应的xi，例如假如我们的字符串只有ascii码，那么我们
 * 可以设计一个256个元素的数组，模式串的字符的ascii码就是数组的下标，而对应的值就是在模式串中最后出现的位置。
 *
 * 而对于好后缀的处理，我们也是在模式串中查找除了最后匹配的那个字串之外，是否还有其它的字串跟好后缀完全一样，找到这个子串在模式串中的起始位置x，
 * 我们记匹配过程中，匹配到坏字符的那个字符的位置为j，然后我们要移动的距离就是j-x+1.
 * 如果模式串中没有跟好后缀一样的除了最后已经匹配的那个字串之外的其它字串，那么我们就查找模式串中从左到右能够跟好后缀从右到左匹配的最长的子串，
 * 如果能够找到模式串中跟好后缀匹配的那个最长的字串，那么我们就将模式串往后移动模式串的长度m-那个能够匹配的字串的长度个位置。
 * 如果上面两个都没有被满足，也就是好后缀在模式串中既没有除了已经匹配的那个字串之外的其他字串，好后缀的后缀字串中也没有能够和模式串的前缀字串一样
 * 的字串，那么就直接将模式串往后移动好后缀个位置。
 *
 * 最后取坏字符和好后缀两者中移动位置最大的那个来作为最终的移动位置。
 *
 * 但是因为坏字符的预处理的哈希算法有很大的局限性，很难设计一个性能很高并且占用空间很小的哈希算法来预处理模式串的坏字符。所以实际在使用中一般只使用
 * 好后缀的这一半的处理逻辑。因为好后缀与字符集无关，也不需要设计哈希算法。只需要预处理一下模式串。
 */
public class BMMatch {
    /**
     * 这里这个大小是假设我们处理的字符都是ascii码对应的字符，那么我们只需要设计一个拥有256个元素的坏字符处理数组就可以预处理模式串
     */
    private int size = 256;

    /**
     * 预处理坏字符，模式串中的每个字符在模式串中最后出现的位置。
     * 这里我们假定要处理的都是ascii码，那么我们定义一个有256个元素的数组，其中字符对应的ascii码就对应数组的下标
     * 而数组下标对应的值就是这个字符在模式串中最后出现的位置。比如模式abcab，a这个元素对应的ascii码是97，
     * 那么坏字符串数组下标为97的那个元素的值就是3，标识a这个元素在模式串中最后出现的位置是3
     * @param pattern
     * @param badCharacter
     */
    private void generateBadCharacter(char [] pattern, int [] badCharacter) {
        /**
         * 首先填充坏字符数组，将每个元素都设置成初始值
         */
        Arrays.fill(badCharacter, -1);
        /**
         * 第一步找到模式串中元素的ascii码，以这个ascii码为下标，在
         * 坏字符数组中将这个下标对应的值设置成字符在模式串中的位置
         */
        for (int i = 0; i < pattern.length; i++) {
            badCharacter[pattern[i]] = i;
        }
    }

    /**
     * 这里对模式串的后缀和前缀匹配进行预处理。
     * 我们假定B[0,i]这个字符串，其中i的取值为[0,m-1],其实B这个字符串就是模式串从左往右的前缀字串
     * 与模式串拥有的公共后缀字串(就是B这个字符串和模式串都从右往左开始访问，有N，N的取值为[0,i-1]个相同的元素，这个拥有相同元素的字串就是我们要找的公共
     * 后缀字串)
     * suffix[k]我们可以理解为从后到前模式串中的有k个元素的后缀子串,其中的值就是对应的跟后缀子串一样的子串最后出现的位置的开始下标
     * prefix[k]我们可以理解为从后道歉模式串中的有k个元素的后缀子串，其中的值就是对应的是否有一个跟当前后缀子串一样的从前到后的模式串中的前缀子串
     * @param pattern
     * @param suffix
     * @param prefix
     */
    private void generateGoodSuffix(char [] pattern,int [] suffix, boolean [] prefix){
        /**
         * 首先初始化后缀字串的数组初始值为-1，表示当前这个子串在模式串中没有对应的跟它一样的字串
         * 初始化前缀匹配字串初始值为false，表示当前这个后最字串在模式串中没有跟它对应的前缀字串
         */
        int m = pattern.length;
        Arrays.fill(suffix,-1);
        Arrays.fill(prefix,false);
        /**
         * 这里我们假象存在一个字串B[0,i],其中i的取值为0到m-1,其实这个B就是模式串的前缀字串，然后我们对每个前缀字串做处理
         */
        for(int i =0; i< m-1; i++){
            /**
             * j用来记录当前这个前缀字串的结束字符的位置，k用来记录公共子串的长度，然后两个字串都从后往前开始访问，依次匹配来查找两个
             * 串对应的公共子串
             */
            int j = i;
            int k = 0;
            /**
             * 这里的逻辑就是从后往前依次对前缀子串和模式串进行匹配，查找匹配上的公共子串。
             * 结束的条件是前缀子串结束或者是匹配到中途的时候对应位置的字符不相等
             * 在查找的过程中，K就是公共子串的长度，那么suffix[k] = j+1,其实就是记录了这个后缀字符串对应的模式串的前缀字符串的开始位置
             */
            while (j >= 0 && pattern[j]== pattern[m-1-k]) {
                j--;
                k++;
                /**
                 * 这段代码的作用就是用来记录suffix[k]这个后缀子串在模式串中存在对应的一样的子串的开始位置
                 */
                suffix[k]=j+1;
            }
            /**
             * 最后如果j等于-1了，表示suffix[k]这个后缀子串有对应的模式串中的前缀子串
             */
            if(j==-1){
                prefix[k]=true;
            }
        }
    }

    private int moveByGoodSuffix(int j,int m, int [] suffix, boolean [] prefix){
        /**
         * 好后缀的长度
         */
        int k = m-1-j;
        /**
         * 如果好后缀在模式串中存在对应的一样的子串，那么取出其开始位置，将模式串往后滑动当前坏字符对应字符在模式串中的位置j-那个对应子串的开始位置，
         * 然后再加1个位置
         */
        if(suffix[k] != -1){
            return j-suffix[k] +1;
        }
        /**
         * 否则就查找是否存在一个模式串中最大前缀子串对应好后缀的后缀子串，如果能够找到这样要给最大的前缀子串
         * 那么将整个模式串往后移动后缀子串长度m,减去匹配上了模式串前缀子串的那个好后缀的后缀子串的长度个位置
         */
        for(int r = j+2; r<m-1; r++){
            if(prefix[m-r]){
                return r;
            }
        }
        /**
         * 如果上面两个条件都不满足，那么就直接把模式串往后移动整个好后缀长度个位置
         */
        return k;
    }

    public int indexOf(char [] main, char [] pattern){
        /**
         * 第一步预处理坏字符串，就是模式串中的每个字符在模式串中最后出现的位置
         */
        int [] badCharacter = new int[size];
        generateBadCharacter(pattern, badCharacter);
        /**
         * 第二部预处理好后缀和好后缀的后缀子串匹配模式串的前缀子串
         */
        int [] suffix = new int[pattern.length];
        boolean [] prefix = new boolean[pattern.length];
        generateGoodSuffix(pattern,suffix,prefix);
        int n = main.length;;
        int m = pattern.length;
        int i =0;
        /**
         * 从主串的第一个位置开始往后进行模式串的匹配
         */
        while(i<n-m){
            int j;
            /**
             * 与模式串匹配的时候，从后往前匹配，当遇到坏字符的时候就退出当前批次匹配过程，j就是坏字符对应的模式串中不匹配的那个字符的位置
             */
            for(j = m-1;j>=0;j--){
                if(main[i+j] != pattern[j]){
                    break;
                }
            }
            /**
             * 如果j小于0了，说明整个模式串匹配完了，那么说明模式串完全匹配了主串中的某个子串，返回当前模式串在主串中的开始位置.
             */
            if(j<0){
                return i;
            }
            /**
             * 第一步求坏字符移动的距离，坏字符移动距离就是当前坏字符的位置减去坏字符在模式串中最后一次出现位置
             */
            int x = j - badCharacter[main[i+j]];
            int y = 0;
            /**
             * 如果j<m-1，表示有好后缀的情况出现，那么找出好后缀的情况要移动的位置
             */
            if(j<m-1){
                y = moveByGoodSuffix(j,m,suffix,prefix);
            }
            /**
             * 最后将模式串往后移动两者中最大位置个数的那个位置。
             */
            i = i+Math.max(x,y);
        }
        return -1;
    }
}
