package com.test.sort;

/**
 * @Auth:jinrun.xie
 * @Date:2020/9/15 插入排序
 * 首先我们将整个要排序的数据分成两个部分，已排序部分和未排序部分，在初始状态下，我们默认第一个元素就是已经排序部分，剩余未排序部分就是未排序部分
 * 然后我们依次取出剩余未排序部分和已排序部分进行比较，找到要插入的位置，然后移动插入位置之后的数据，最后将数据插入到新位置，在这里我们遍历查找的过程中，我们使用逆序遍历
 * 也就是从当前要排序数字的位置开始从后往前遍历已排序部分，这样找到要插入位置
 * 平均时间复杂度O(n²),是一种稳定的排序算法
 **/
public class InsertSort {

    public void sort(int[] arr, int n) {
        if (n <= 1) {
            return;
        }
        //这里i从1开始就是我们默认第一个元素已经是已排序部分，从第二个元素开始从后往前遍历已排序部分，找到对应位置插入，并且在遍历过程中移动元素的位置
        for (int i = 1; i < n; i++) {
            int value = arr[i];
            int j = i - 1;
            //从后往前遍历已排序部分，并且在遍历过程中，如果要插入的元素比数组下标对应的元素小，那么就将当前数组下标元素后移一位
            for (; j >= 0; j--) {
                if (value < arr[j]) {
                    arr[j + 1] = arr[j];
                } else {
                    break;
                }
            }
            arr[j + 1] = value;
        }
    }
}
